//@author: a0097582n



	/**
	 * origin: src\taskie\commands\AddCommand.java
	 */

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;

import taskie.exceptions.TaskModificationFailedException;
import taskie.exceptions.TaskRetrievalFailedException;
import taskie.exceptions.TaskTypeNotSupportedException;
import taskie.models.CommandType;
import taskie.models.DisplayType;
import taskie.models.Messages;
import taskie.models.Task;
import taskie.models.TaskType;

public class AddCommand extends AbstractCommand {
	private String _taskName;
	private LocalDate _startDate;
	private LocalTime _startTime;
	private LocalDate _endDate;
	private LocalTime _endTime;
	private CommandType _commandType = CommandType.ADD;
	private Task _task;
	private ArrayList<Task> _conflictedTask;

	public AddCommand() {
		_taskName = null;
		_startDate = null;
		_startTime = null;
		_endDate = null;
		_endTime = null;
	}

	public AddCommand(Task task) {
		_taskName = task.getTitle();
		_startDate = task.getStartDate();
		_startTime = task.getStartTime();
		_endDate = task.getEndDate();
		_endTime = task.getEndTime();
	}

	public AddCommand(String taskName, LocalDate startDate,
			LocalTime startTime, LocalDate endDate, LocalTime endTime) {
		super();
		_taskName = taskName;
		_startDate = startDate;
		_startTime = startTime;
		_endDate = endDate;
		_endTime = endTime;
	}

	public AddCommand(String taskName, LocalDateTime startDateTime,
			LocalDateTime endDateTime) {
		super();
		_taskName = taskName;
		this.setStartDateTime(startDateTime);
		this.setEndDateTime(endDateTime);
	}

	public String getTaskName() {
		return _taskName;
	}

	public void setTaskName(String _taskName) {
		this._taskName = _taskName;
	}

	public LocalDate getStartDate() {
		return _startDate;
	}

	public void setStartDate(LocalDate _startDate) {
		this._startDate = _startDate;
	}

	public LocalTime getStartTime() {
		return _startTime;
	}

	public void setStartTime(LocalTime _startTime) {
		this._startTime = _startTime;
	}

	public LocalDate getEndDate() {
		return _endDate;
	}

	public void setEndDate(LocalDate _endDate) {
		this._endDate = _endDate;
	}

	public LocalTime getEndTime() {
		return _endTime;
	}

	public void setEndTime(LocalTime _endTime) {
		this._endTime = _endTime;
	}

	// End of segment: src\taskie\commands\AddCommand.java





	/**
	 * origin: src\taskie\commands\AddCommand.java
	 */

	private boolean hasNoConflict() throws TaskRetrievalFailedException {
		Boolean hasNoConflict=true; 
		_conflictedTask = new ArrayList<Task>();
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		for (int i=0;i<list.size();i++) {
			Task task = list.get(i);
			if (hasConflict(task, this._task)) {
				_conflictedTask.add(task);
				hasNoConflict=false;
			}
		}
		return hasNoConflict;
	}

	private boolean hasConflict(Task task1, Task task2) {
		if (task1.getTaskType() == TaskType.TIMED
				&& task2.getTaskType() == TaskType.TIMED) {
			if(hasTimeOverlap(task1, task2)){
				return true;
			}
		}
		return false;
	}

	private boolean hasTimeOverlap(Task task1, Task task2) {
		if(task1.getStartDateTime().isBefore(task2.getEndDateTime())
				&&task2.getStartDateTime().isBefore(task1.getEndDateTime())){
		return true;
		}
		return false;
	}

	private String formatAddMsg(Task task) {
		TaskType type = task.getTaskType();
		if (type == TaskType.FLOATING) {
			return String.format(taskie.models.Messages.ADD_FLOATING,
					task.getTitle());
		} else if (type == TaskType.DEADLINE) {
			return String.format(taskie.models.Messages.ADD_DEADLINED,
					task.getTitle(),
					_controller.getUI().formatDateTime(task.getEndDateTime()));
		} else {
			return String
					.format(taskie.models.Messages.ADD_TIMED,
							task.getTitle(),
							_controller.getUI().formatDateTime(
									task.getStartDateTime()),
							_controller.getUI().formatDateTime(
									task.getEndDateTime()));
		}
	}
	
	private String formatAddMsgWithWarning(Task newTask) {
		StringBuilder sb = new StringBuilder();
		sb.append(String.format(Messages.ADD_TIMED, newTask.getTitle()
				, _controller.getUI().formatDateTime(newTask.getStartDateTime())
				, _controller.getUI().formatDateTime(newTask.getEndDateTime())));
			sb.append(Messages.ADD_CONFLICT);
		for(int i=0;i<_conflictedTask.size();i++){
			Task task = _conflictedTask.get(i);
			if(i==_conflictedTask.size()-1 && i !=0){
				sb.append("and ");
				sb.append(task.getTitle());
				sb.append(".");
			}else if(i==_conflictedTask.size()-1 && i==0){
				sb.append(task.getTitle()+".");
			}else{
				sb.append(task.getTitle());
				sb.append(", ");
			}
		}
		sb.append(Messages.NEWLINE);
		return sb.toString();
	}

	// End of segment: src\taskie\commands\AddCommand.java





	/**
	 * origin: src\taskie\commands\Command.java
	 */


package taskie.commands;

import taskie.exceptions.UndoNotSupportedException;
import taskie.models.CommandType;

public interface Command {
	public CommandType getCommandType();

	public boolean execute();
	
	public void undo() throws UndoNotSupportedException;
}

	// End of segment: src\taskie\commands\Command.java





	/**
	 * origin: src\taskie\commands\DeleteCommand.java
	 */


package taskie.commands;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;

import taskie.exceptions.InvalidTaskException;
import taskie.exceptions.TaskModificationFailedException;
import taskie.exceptions.TaskRetrievalFailedException;
import taskie.exceptions.TaskTypeNotSupportedException;
import taskie.models.CommandType;
import taskie.models.DisplayType;
import taskie.models.Messages;
import taskie.models.Task;

public class DeleteCommand extends AbstractCommand {
	private ArrayList<Task> _tasks = new ArrayList<Task>();
	private int[] _taskIndexes;
	Logger _logger;

	private Task _currentTask;
	private Boolean _deleteStartDate = false;
	private Boolean _deleteStartTime = false;
	private Boolean _deleteEndDate = false;
	private Boolean _deleteEndTime = false;

	private CommandType _commandType = CommandType.DELETE;

	// End of segment: src\taskie\commands\DeleteCommand.java





	/**
	 * origin: src\taskie\commands\DeleteCommand.java
	 */

	public void setToDeleteStartDate() {
		_deleteStartDate = true;
		_deleteStartTime = true; // if startDate is to be deleted, startTime
									// will be deleted too
	}

	public Boolean canDeleteStartDate() {
		return _deleteStartDate;
	}

	public void setToDeleteStartTime() {
		_deleteStartTime = true;
	}

	public Boolean canDeleteStartTime() {
		return _deleteStartTime;
	}

	public void setToDeleteEndDate() {
		_deleteEndDate = true;
		_deleteEndTime = true; // if endDate is to be deleted, endTime will be
								// deleted too
	}

	public Boolean canDeleteEndDate() {
		return _deleteEndDate;
	}

	public void setToDeleteEndTime() {
		_deleteEndTime = true;
	}

	public Boolean canDeleteEndTime() {
		return _deleteEndTime;
	}

	@Override
	public CommandType getCommandType() {
		return _commandType;
	}

	@Override
	public boolean execute() {
		_logger = Logger.getLogger(DeleteCommand.class.getName());
		_logger.log(Level.INFO,"CommandType: "+this.getCommandType()+"  taskindexes: "
		+_taskIndexes+"\ndeleteStartDate: "+_deleteStartDate+"  deleteStartTime: "
				+_deleteStartTime+"\ndeleteEndDate: "+_deleteEndDate+"  deleteEndTime: "+_deleteEndTime);
		
		this.retrieveTasks();
		boolean success = true;

		for (Task task : _tasks) {
			try {
				_currentTask = task;
				if (canDeleteStartDate() || canDeleteStartTime() || canDeleteEndDate() || canDeleteEndTime()) {
					// if either of these methods returned true, only task
					// fields are to be deleted.
					deleteTaskField(task);
					_controller.getUI().display(DisplayType.SUCCESS, formatDeleteTaskFieldString());
				} else {
					deleteTask();
					_controller.getUI().display(DisplayType.SUCCESS, formatDeleteTaskString());
				}
			} catch (TaskTypeNotSupportedException e) {
				_controller.getUI().display(DisplayType.ERROR, e.getMessage());
				success = false;
			} catch (TaskModificationFailedException e) {
				_controller.getUI().display(DisplayType.ERROR, e.getMessage());
				success = false;
			}
		}

		return success;
	}

	private void deleteTaskField(Task task) throws TaskTypeNotSupportedException, TaskModificationFailedException {
		// taskfields are deleted by setting to them null;

		if (!canDeleteStartDate() && canDeleteEndDate()) {// switch start and
															// end date if del
															// end date;
			Task updatedTask = new Task(task.getTitle(), task.getStartDate(), task.getStartTime());
			_controller.getStorage().updateTask(task, updatedTask);
			return;
		}else if (canDeleteStartDate()&&canDeleteEndDate()) {
			Task updatedTask = new Task(task.getTitle());
			_controller.getStorage().updateTask(task, updatedTask);
			return;
		}else if (canDeleteStartDate()) {
			Task updatedTask = new Task(task.getTitle(), task.getEndDate(), task.getEndTime());
			_controller.getStorage().updateTask(task, updatedTask);
			return;
		}
		if (canDeleteStartTime()) {
			_logger.log(Level.INFO, "Deleting startTime.");
			Task updatedTask = new Task(task.getTitle(), task.getStartDate(), null, task.getEndDate(), task.getEndTime());
			_controller.getStorage().updateTask(task, updatedTask);
			task=updatedTask;
			
		}
		if (canDeleteEndTime()) {
			_logger.log(Level.INFO, "Deleting endTime.");
			Task updatedTask = new Task(task.getTitle(), task.getStartDate(), task.getStartTime(), task.getEndDate(), null);
			_controller.getStorage().updateTask(task, updatedTask);
		}

	}

	// End of segment: src\taskie\commands\DeleteCommand.java





	/**
	 * origin: src\taskie\commands\DeleteCommand.java
	 */

	private String formatDeleteTaskString() {
		return String.format(taskie.models.Messages.DELETE_TASK, _currentTask.getTitle());
	}

	private String formatDeleteTaskFieldString() {
		StringBuffer fields = new StringBuffer();
		
		if (canDeleteStartDate()) {
			fields.append(Messages.START_DATE_STRING);
		}
		if (canDeleteStartTime()) {
			fields.append(Messages.START_TIME_STRING);
		}
		if (canDeleteEndDate()) {
			fields.append(Messages.END_DATE_STRING);
		}
		if (canDeleteEndTime()) {
			fields.append(Messages.END_TIME_STRING);
		}	
		
		return String.format(taskie.models.Messages.DELETE_TASK_FIELD, _currentTask.getTitle(), fields.substring(0, fields.length() - 2));
	}

	// End of segment: src\taskie\commands\DeleteCommand.java





	/**
	 * origin: src\taskie\commands\MarkCommand.java
	 */

package taskie.commands;

import java.util.ArrayList;
import java.util.Arrays;

import taskie.exceptions.InvalidTaskException;
import taskie.exceptions.TaskModificationFailedException;
import taskie.exceptions.TaskRetrievalFailedException;
import taskie.exceptions.TaskTypeNotSupportedException;
import taskie.models.CommandType;
import taskie.models.DisplayType;
import taskie.models.Messages;
import taskie.models.Task;

public class MarkCommand extends AbstractCommand {
	private CommandType _commandType = CommandType.MARK;
	private Task _currentTask;

	private ArrayList<Task> _tasks = new ArrayList<Task>();
	private int[] _taskIndexes;

	// End of segment: src\taskie\commands\MarkCommand.java





	/**
	 * origin: src\taskie\commands\MarkCommand.java
	 */

	public CommandType getCommandType() {
		return _commandType;
	}

	public boolean execute() {
		this.retrieveTasks();
		boolean success = true;

		for (Task task : _tasks) {
			try {
				_currentTask = task;

				if (_currentTask.isDone()) {
					_controller.getUI().display(DisplayType.ERROR, formatAlreadyMarkString());
				} else {
					_currentTask.setTaskDone();
					_controller.getUI().display(DisplayType.SUCCESS, formatMarkString());
					_controller.getStorage().updateTask(_currentTask, _currentTask);
				}

				_controller.setLastTask(_currentTask);
			} catch (TaskTypeNotSupportedException e) {
				_controller.getUI().display(DisplayType.ERROR, e.getMessage());
				success = false;
			} catch (TaskModificationFailedException e) {
				_controller.getUI().display(DisplayType.ERROR, e.getMessage());
				success = false;
			}
		}

		if (_tasks.size() > 1) {
			_controller.setLastTask(null);
		}
		
		return success;
	}
	
	private String formatAlreadyMarkString() {
		return String.format(taskie.models.Messages.TASK_ALREADY_DONE, _currentTask.getTitle());
	}

	private String formatMarkString() {
		return String.format(taskie.models.Messages.MARK_STRING, _currentTask.getTitle());
	}

	// End of segment: src\taskie\commands\MarkCommand.java





	/**
	 * origin: src\taskie\commands\UnmarkCommand.java
	 */

package taskie.commands;

import java.util.ArrayList;
import java.util.Arrays;

import taskie.exceptions.InvalidTaskException;
import taskie.exceptions.TaskModificationFailedException;
import taskie.exceptions.TaskRetrievalFailedException;
import taskie.exceptions.TaskTypeNotSupportedException;
import taskie.models.CommandType;
import taskie.models.DisplayType;
import taskie.models.Messages;
import taskie.models.Task;

public class UnmarkCommand extends AbstractCommand {
	private CommandType _commandType = CommandType.MARK;
	private Task _currentTask;

	private ArrayList<Task> _tasks = new ArrayList<Task>();
	private int[] _taskIndexes;

	// End of segment: src\taskie\commands\UnmarkCommand.java





	/**
	 * origin: src\taskie\commands\UnmarkCommand.java
	 */

	public CommandType getCommandType() {
		return _commandType;
	}

	public boolean execute() {
		boolean success = true;
		this.retrieveTasks();
		
		for (Task task : _tasks) {
			try {
				_currentTask = task;

				if (_currentTask.isDone()) {
					_currentTask.setTaskUndone();
					_controller.getUI().display(DisplayType.SUCCESS, formatUnmarkString());
					_controller.getStorage().updateTask(_currentTask, _currentTask);
				} else {
					_controller.getUI().display(DisplayType.ERROR, formatAlreadyUnmarkedString());
				}

				_controller.setLastTask(_currentTask);
			} catch (TaskTypeNotSupportedException e) {
				_controller.getUI().display(DisplayType.ERROR, e.getMessage());
				success = false;
			} catch (TaskModificationFailedException e) {
				_controller.getUI().display(DisplayType.ERROR, e.getMessage());
				success = false;
			}
		}

		if (_tasks.size() > 1) {
			_controller.setLastTask(null);
		}
		
		return success;
	}

	private String formatAlreadyUnmarkedString() {
		return String.format(taskie.models.Messages.TASK_ALREADY_NOT_DONE, _currentTask.getTitle());
	}
	
	private String formatUnmarkString() {
		return String.format(taskie.models.Messages.UNMARK_STRING, _currentTask.getTitle());
	}

	// End of segment: src\taskie\commands\UnmarkCommand.java





	/**
	 * origin: src\taskie\commands\UpdateCommand.java
	 */


package taskie.commands;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.logging.Level;
import java.util.logging.Logger;

import taskie.exceptions.InvalidCommandException;
import taskie.exceptions.InvalidTaskException;
import taskie.exceptions.TaskDateInvalidException;
import taskie.exceptions.TaskDateNotSetException;
import taskie.exceptions.TaskModificationFailedException;
import taskie.exceptions.TaskRetrievalFailedException;
import taskie.exceptions.TaskTypeNotSupportedException;
import taskie.models.CommandType;
import taskie.models.DisplayType;
import taskie.models.Messages;
import taskie.models.Task;

public class UpdateCommand extends AbstractCommand {
	int NUM_ATTRIBUTE = 2;
	private Task _oldTask;
	private Task _task;

	private int _taskIndex;
	private String _taskTitleToUpdate = null;
	private LocalDate _startDateToUpdate = null;
	private LocalTime _startTimeToUpdate = null;
	private LocalDate _endDateToUpdate = null;
	private LocalTime _endTimeToUpdate = null;

	private Boolean _isToUpdateTaskTitle = false;
	private Boolean _isToUpdateStartDate = false;
	private Boolean _isToUpdateStartTime = false;
	private Boolean _isToUpdateEndDate = false;
	private Boolean _isToUpdateEndTime = false;
	private CommandType _commandType = CommandType.UPDATE;

	private Logger _logger = Logger.getLogger(UpdateCommand.class.getName());

	public UpdateCommand(Task task) {
		_task = task;
	}

	public UpdateCommand(int taskIndex) {
		_taskIndex = taskIndex;
	}

	public CommandType getCommandType() {
		return _commandType;
	}

	public void setTaskTitleToUpdate(String title) {
		_isToUpdateTaskTitle = true;
		_taskTitleToUpdate = title.trim();
	}

	public String getTaskTitleToUpdate() {
		return _taskTitleToUpdate;
	}

	public LocalDate getStartDateToUpdate() {
		return _startDateToUpdate;
	}

	public void setStartDateToUpdate(LocalDate startDateToUpdate) {
		_isToUpdateStartDate = true;
		this._startDateToUpdate = startDateToUpdate;
	}

	public LocalTime getStartTimeToUpdate() {
		return _startTimeToUpdate;
	}

	public void setStartTimeToUpdate(LocalTime startTimeToUpdate) {
		_isToUpdateStartTime = true;
		this._startTimeToUpdate = startTimeToUpdate;
	}

	public LocalDate getEndDateToUpdate() {
		return _endDateToUpdate;
	}

	public void setEndDateToUpdate(LocalDate endDateToUpdate) {
		_isToUpdateEndDate = true;
		this._endDateToUpdate = endDateToUpdate;
	}

	public LocalTime getEndTimeToUpdate() {
		return _endTimeToUpdate;
	}

	public void setEndTimeToUpdate(LocalTime endTimeToUpdate) {
		_isToUpdateEndTime = true;
		this._endTimeToUpdate = endTimeToUpdate;
	}

	public Boolean isModifiedTaskTitle() {
		return _isToUpdateTaskTitle;
	}

	public Boolean isModifiedStartDate() {
		return _isToUpdateStartDate;
	}

	public Boolean isModifiedStartTime() {
		return _isToUpdateStartTime;
	}

	public Boolean isModifiedEndDate() {
		return _isToUpdateEndDate;
	}

	public Boolean isModifiedEndTime() {
		return _isToUpdateEndTime;
	}

	public boolean execute() {
		boolean success = true;
		_logger.log(Level.INFO, "UPDATECOMMAND CONFIG: task Index: " + _taskIndex + " taskTitleToUpdate: " + _taskTitleToUpdate + "\nstartdate(bool): " + _startDateToUpdate + " " + _isToUpdateStartDate + "  time(bool): " + _startTimeToUpdate + " " + _isToUpdateStartTime + "\nendDate(bool): " + _endDateToUpdate + " " + _isToUpdateEndDate + " time(bool):" + _endTimeToUpdate + " " + _isToUpdateEndTime);

		try {
			if (_task == null) {
				_task = retrieveTaskToUpdate();
			}
			_logger.log(Level.INFO, "TASK FROM UI: " + _task.toString());
			
			_oldTask = new Task(_task);
			_task = updateTask(_task);
			_logger.log(Level.INFO, "UPDATED TASK: "+_task.toString());
			_controller.getStorage().updateTask(_task, _task);
			_controller.getUI().display(DisplayType.SUCCESS, formatUpdateMsg(_oldTask, _task));
		} catch (InvalidTaskException e) {
			_controller.getUI().display(DisplayType.ERROR, Messages.INVALID_TASK_NUM);
			success = false;
		} catch (InvalidCommandException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
			success = false;
		} catch (TaskTypeNotSupportedException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
			success = false;
		} catch (TaskModificationFailedException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
			success = false;
		} catch (TaskDateNotSetException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
			success = false;
		} catch (TaskDateInvalidException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
			success = false;
		} catch (TaskRetrievalFailedException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
			success = false;
		}
		
		return success;
	}

	private Task updateTask(Task task) throws InvalidCommandException, TaskDateNotSetException, TaskDateInvalidException {
		task.setTitle(isModifiedTaskTitle() && !_taskTitleToUpdate.isEmpty() ? _taskTitleToUpdate : task.getTitle());
		task.setStartDateTime(isModifiedStartDate() ? _startDateToUpdate : task.getStartDate(), isModifiedStartTime() ? _startTimeToUpdate : task.getStartTime());
		task.setEndDateTime(isModifiedEndDate() ? _endDateToUpdate : task.getEndDate(), isModifiedEndTime() ? _endTimeToUpdate : task.getEndTime());
		return task;
	}

	private String formatUpdateMsg(Task oldTask, Task newTask) {
		String message = String.format(Messages.UPDATE_STRING, oldTask.getTitle());
		if (this.isModifiedTaskTitle()) {
			message = message.concat(String.format(Messages.TASK_TITLE, oldTask.getTitle(), newTask.getTitle()));
		}
		if (this.isModifiedStartDate() || this.isModifiedStartTime()) {
			if (oldTask.getStartDateTime() == null) {
				message = message.concat(String.format(Messages.START_DATE_TIME_NULL, _controller.getUI().formatDateTime(newTask.getStartDateTime())));
			} else if ( newTask.getStartDateTime() == null ) {
				message = message.concat(taskie.models.Messages.UPDATE_START_DATE_REMOVED);
			} else {
				message = message.concat(String.format(Messages.START_DATE_TIME, _controller.getUI().formatDateTime(oldTask.getStartDateTime()), _controller.getUI().formatDateTime(newTask.getStartDateTime())));
			}
		}
		if (this.isModifiedEndDate() || this.isModifiedEndTime()) {
			if (oldTask.getEndDateTime() == null) {
				message = message.concat(String.format(Messages.END_DATE_TIME_NULL, _controller.getUI().formatDateTime(newTask.getEndDateTime())));
			} else if ( newTask.getEndDateTime() == null ) {
				message = message.concat(taskie.models.Messages.UPDATE_START_DATE_REMOVED);
			} else {
				message = message.concat(String.format(taskie.models.Messages.END_DATE_TIME, _controller.getUI().formatDateTime(oldTask.getEndDateTime()), _controller.getUI().formatDateTime(newTask.getEndDateTime())));
			}
		}
		return message;
	}

	private Task retrieveTaskToUpdate() throws InvalidTaskException, TaskRetrievalFailedException, InvalidCommandException {
		Task task = null;
		if (_taskIndex == 0) {
			task = _controller.getLastTask();
		} else {
			task = _controller.getUI().getTask(_taskIndex);
			_controller.setLastTask(task);
		}

		if (task == null) {
			throw new InvalidCommandException();
		}

		return task;
	}

	// End of segment: src\taskie\commands\UpdateCommand.java





	/**
	 * origin: src\taskie\commands\ViewCommand.java
	 */

	@Override
	public boolean execute() {
		_logger.log(
				Level.INFO,
				"ViewType: " + this._viewType + "\nStartDate: "
						+ this.getStartDate() + " StartTime: "
						+ this.getStartTime() + "\nEndDate: "
						+ this.getEndDate() + " EndTime: " + this.getEndTime()
						+ "\nSearch Keywords: " + this.getSearchKeywords());
		switch (_viewType) {
		case ALL:
			executeViewAll();
			break;
		case UPCOMING:
			executeViewUpcoming();
			break;
		case OVERDUE:
			executeViewOverdue();
			break;
		case COMPLETED:
			executeViewCompleted();
			break;
		case SEARCH:
			executeViewSearch();
			break;
		}
		
		return true;
	}


	/**
	 * This method acts as a filter to filter tasklists by done status.
	 * @param tasks
	 * @return ArrayList<Task>
	 */
	private ArrayList<Task> findUndoneTasks(ArrayList<Task> tasks) {
		ArrayList<Task> tasksToDisplay = new ArrayList<Task>();
		for(Task task: tasks){
			if(!task.isDone()){
				tasksToDisplay.add(task);
			}
		}
		return tasksToDisplay;
	}

	private ArrayList<Task> findTasksByDate(ArrayList<Task> tasks) {
		if (_startDate == null) {
			_logger.log(Level.INFO, "Search type: Enddate");
			return findTasksBeforeEndDate(tasks);
		} else if (_endDate == null) {
			_logger.log(Level.INFO, "Search type: Startdate");
			return findTasksFromStartDate(tasks);
		} else {
			_logger.log(Level.INFO, "Search type: StartEnddate");
			return findTasksBetweenDates(tasks);
		}
	}

	private ArrayList<Task> findTasksBeforeEndDate(ArrayList<Task> tasks) {
		ArrayList<Task> tasksToDisplay = new ArrayList<Task>();
		LocalDateTime endDateTime = this.getEndDateTime();

		for (Task task : tasks) { 
			TaskType taskType = task.getTaskType();
			if (taskType == TaskType.FLOATING) {
				tasksToDisplay.add(task);
			} else if (taskType == TaskType.DEADLINE						
					&& task.getEndDateTime().isBefore(endDateTime)) {
				tasksToDisplay.add(task);
			} else if ((taskType == TaskType.TIMED
					&& task.getStartDateTime().isBefore(endDateTime))) {
				tasksToDisplay.add(task);
			}
			
		}
		return tasksToDisplay;
	}

	private ArrayList<Task> findTasksFromStartDate(ArrayList<Task> tasks) {
		ArrayList<Task> tasksToDisplay = new ArrayList<Task>();
		LocalDateTime startDateTime = this.getStartDateTime();

		for (Task task : tasks) {
		
			TaskType taskType = task.getTaskType();
			assert taskType != null;
			if (taskType == TaskType.FLOATING) {
				tasksToDisplay.add(task);
				} else {
				if (task.getEndDateTime().isAfter(startDateTime)) {
					tasksToDisplay.add(task);
				}
			}
		}
		return tasksToDisplay;
	}

	private ArrayList<Task> findTasksBetweenDates(ArrayList<Task> tasks) {
		ArrayList<Task> tasksToDisplay = new ArrayList<Task>();
		LocalDateTime startDateTime = this.getStartDateTime();
		LocalDateTime endDateTime = this.getEndDateTime();

		for (Task task : tasks) {
			TaskType taskType = task.getTaskType();
			if (taskType == TaskType.FLOATING) {
				tasksToDisplay.add(task);
			} else if (taskType == TaskType.DEADLINE) {
				if (task.getEndDateTime().isAfter(startDateTime)
						&& task.getEndDateTime().isBefore(endDateTime)) {
					tasksToDisplay.add(task);
				}
				} else {
				assert taskType != null;
				if (task.getStartDateTime().isBefore(endDateTime)
						&& task.getEndDateTime().isAfter(startDateTime)) {
					tasksToDisplay.add(task);					}
				}
		}
		return tasksToDisplay;
	}

	private ArrayList<Task> findSearchedTasks(ArrayList<Task> tasks) {
		ArrayList<Task> searchedTasks = new ArrayList<Task>();
		for (Task task : tasks) {
			String taskTitle = task.getTitle();
			taskTitle = taskTitle.toLowerCase();
			if (taskTitle.contains(_searchKeywords.trim())) {
				searchedTasks.add(task);
			}
		}
		return searchedTasks;
	}
	
	
	private void executeViewSearch() {
		ArrayList<Task> tasks = null;
		ArrayList<Task> tasksToDisplay = null;
		try {
			tasks = _controller.getStorage().getTaskList();
			if (_startDate == null && _endDate == null
					&& _searchKeywords != null) {
				tasksToDisplay = findSearchedTasks(tasks);
				_logger.log(Level.INFO, "searchType: Taskname\n");
			} else if (_searchKeywords != null) {
				tasksToDisplay = findTasksByDate(tasks);
				tasksToDisplay = findSearchedTasks(tasksToDisplay);
			} else {
				tasksToDisplay = findTasksByDate(tasks);
			}
			tasksToDisplay = findUndoneTasks(tasksToDisplay);
			tasksToDisplay.sort(new TaskEndDateComparator());
			_controller.getUI().display(
					tasksToDisplay.toArray(new Task[tasksToDisplay.size()]));
		} catch (TaskRetrievalFailedException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
		}
	}
	private void executeViewOverdue() {
		ArrayList<Task> tasks = null;
		ArrayList<Task> tasksToDisplay = new ArrayList<Task>();
		LocalDateTime now = LocalDateTime.now();

		try {
			tasks = _controller.getStorage().getTaskList();
			for (Task task : tasks) {
				if (!task.isDone()) {
					TaskType taskType = task.getTaskType();
					if (taskType == TaskType.FLOATING) {
						tasksToDisplay.add(task);
					} else if (task.getEndDateTime().isBefore(now)) {
						tasksToDisplay.add(task);
					}
				}
			}
			tasksToDisplay.sort(new TaskEndDateComparator());
			_controller.getUI().display(
					tasksToDisplay.toArray(new Task[tasksToDisplay.size()]));
		} catch (TaskRetrievalFailedException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
		}
	}

	private void executeViewCompleted() {
		ArrayList<Task> tasks = null;
		ArrayList<Task> tasksToDisplay = new ArrayList<Task>();

		try {
			tasks = _controller.getStorage().getTaskList();
			for (Task task : tasks) {
				if (task.isDone()) {
					tasksToDisplay.add(task);

				}
			}
			tasksToDisplay.sort(new TaskEndDateComparator());
			_controller.getUI().display(
					tasksToDisplay.toArray(new Task[tasksToDisplay.size()]));
		} catch (TaskRetrievalFailedException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
		}
	}

	private void executeViewUpcoming() {
		ArrayList<Task> tasks = null;
		ArrayList<Task> tasksToDisplay = new ArrayList<Task>();

		try {
			tasks = _controller.getStorage().getTaskList();
			for (Task task : tasks) {
				if (!task.isDone()) {
					tasksToDisplay.add(task);
				}

			}
			tasksToDisplay.sort(new TaskEndDateComparator());
			_controller.getUI().display(
					tasksToDisplay.toArray(new Task[tasksToDisplay.size()]));
		} catch (TaskRetrievalFailedException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
		}
	}

	private ArrayList<Task> executeViewAll() {
		ArrayList<Task> tasksToDisplay = new ArrayList<Task>();
		ArrayList<Task> doneTasksToDisplay = new ArrayList<Task>();
		try {

			ArrayList<Task> tasks = _controller.getStorage().getTaskList();
			for (Task task : tasks) {
				if (!task.isDone()) {
					tasksToDisplay.add(task);
				} else {
					doneTasksToDisplay.add(task);
				}
			}
			if(_startDate!=null || _endDate!=null){
				tasksToDisplay = findTasksByDate(tasksToDisplay);
				doneTasksToDisplay = findTasksByDate(doneTasksToDisplay);
			}
			if(_searchKeywords!=null){
				tasksToDisplay=findSearchedTasks(tasksToDisplay);
				doneTasksToDisplay = findTasksByDate(doneTasksToDisplay);
			}
			
			tasksToDisplay.sort(new TaskEndDateComparator());
			doneTasksToDisplay.sort(new TaskEndDateComparator());
			tasksToDisplay.addAll(doneTasksToDisplay);
			_controller.getUI().display(
					tasksToDisplay.toArray(new Task[tasksToDisplay.size()]));
		} catch (TaskRetrievalFailedException e) {
			_controller.getUI().display(DisplayType.ERROR, e.getMessage());
		}
		return tasksToDisplay;
	}

	// End of segment: src\taskie\commands\ViewCommand.java





	/**
	 * origin: src\taskie\Controller.java
	 */


package taskie;

import java.io.IOException;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

import taskie.commands.ExitCommand;
import taskie.commands.Command;
import taskie.database.Configuration;
import taskie.database.Storage;
import taskie.database.NStorage;
import taskie.exceptions.InvalidCommandException;
import taskie.exceptions.TaskRetrievalFailedException;
import taskie.models.CommandType;
import taskie.models.DisplayType;
import taskie.models.Messages;
import taskie.models.Task;
import taskie.parser.CommandParser;
import taskie.parser.Parser;
import taskie.ui.CommandUI;
import taskie.ui.UI;

public class Controller {
	private static Controller _instance;
	private Configuration _config;
	private Logger _logger;
	private Parser _parser;
	private Stack<Command> _undoStack;
	private Stack<Command> _redoStack;
	private Task _lastTask;

	protected UI _ui;
	protected Storage _storage;

	public UI getUI() {
		return _ui;
	}

	public Storage getStorage() {
		return _storage;
	}

	public Parser getParser() {
		return _parser;
	}

	public Configuration getConfiguration() {
		return _config;
	}

	private Controller() {
		_logger = Logger.getLogger(Controller.class.getName());
		_config = Configuration.getInstance();
		_ui = new CommandUI(this);
		_parser = new CommandParser();
		this.initialize();
	}

	private void initialize() {
		try {
			_undoStack = new Stack<Command>();
			_redoStack = new Stack<Command>();
			_storage = new NStorage(_config.getDatabasePath());
			_lastTask = null;
		} catch (IOException e) {
			_logger.log(Level.SEVERE, Messages.STORAGE_INITIALISATION_ERROR);
			System.out.println(Messages.STORAGE_INITIALISATION_ERROR);
		}
	}
	
	public static Controller getInstance() {
		if (_instance == null) {
			_instance = new Controller();
		}
		return _instance;
	}

	public Task getLastTask() throws TaskRetrievalFailedException {
		if (_lastTask == null) {
			throw new TaskRetrievalFailedException();
		}
		return _lastTask;
	}

	public void setLastTask(Task task) {
		_lastTask = task;
	}

	public void run() {
		_ui.run();

		while (_ui.isUIRunning()) {
			String string = _ui.readInput();
			if (string == null) {
				this.executeCommand(new ExitCommand());
			} else {
				if (!string.isEmpty()) {
					try {
						Command cmd = _parser.parse(string);
						this.executeCommand(cmd);
					} catch (InvalidCommandException e) {
						_ui.display(DisplayType.ERROR, Messages.INVALID_COMMAND);
					}
				}
			}
		}
	}

	public void executeCommand(Command command) {
		boolean success = command.execute();
		if ( success ) { 
			addTaskHistory(command);
		}
	}

	// End of segment: src\taskie\Controller.java





	/**
	 * origin: src\taskie\models\Messages.java
	 */

public class Messages {
	public static final String NEWLINE = System.lineSeparator();
	public static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("EEEE, dd MMMM yyyy");
	public static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("hh:mma");
	public static final DateTimeFormatter DATETIME_FORMAT = DateTimeFormatter.ofPattern("EEEE, dd MMMM yyyy hh:mma");

	// UI Messages
	public static final String UI_WELCOME_MESSAGE = "Welcome to Taskie!";
	public static final String UI_REQUEST_INPUT = "Enter Command: ";
	public static final String UI_HEADER = "Your To-Do List";
	public static final String UI_NO_TASKS = "No tasks found!";

	// AddCommand messages
	public static final String ADD_FLOATING = "%s added." + NEWLINE;
	public static final String ADD_DEADLINED = "%s added at %s" + NEWLINE;
	public static final String ADD_TIMED = "%s added from %s to %s" + NEWLINE;
	public static final String ADD_CONFLICT = "[!!!] Warning! This task conflicts with: ";

	// DeleteCommand messages
	public static final String DELETE_TASK = "%s has been deleted." + NEWLINE;
	public static final String DELETE_TASK_FIELD = "The following fields have been deleted from %s: %s" + NEWLINE;
	public static final String START_DATE_STRING = "start date, ";
	public static final String START_TIME_STRING = "start time, ";
	public static final String END_DATE_STRING = "end date, ";
	public static final String END_TIME_STRING = "end time, ";

	// ExitCommand messages
	public static final String EXIT_MESSAGE = "Taskie is exiting. Hope to see you again!";

	// MarkCommand messages
	public static final String MARK_STRING = "%s marked as complete." + NEWLINE;
	public static final String TASK_ALREADY_DONE = "%s is already complete." + NEWLINE;

	// UnmarkCommand messages
	public static final String UNMARK_STRING = "%s marked as incomplete" + NEWLINE;
	public static final String TASK_ALREADY_NOT_DONE = "%s is already incomplete." + NEWLINE;

	// UpdateCommand messages
	public static final String UPDATE_STRING ="%s has been updated as follows:" + NEWLINE;
	public static final String INVALID_DATE_INPUT = "Invalid Command. Date input is not valid. Please try again." + NEWLINE;
	public static final String TASK_TITLE = "Task Title has changed from %s to %s" + NEWLINE;
	public static final String START_DATE_TIME = "Start date and time changed from %s to %s" + NEWLINE;
	public static final String END_DATE_TIME = "End date and time changed from %s to %s" + NEWLINE;
	public static final String START_DATE_TIME_NULL = "Task start date updated to %s." + NEWLINE;
	public static final String END_DATE_TIME_NULL = "Task end date updated to %s." +NEWLINE;
	public static final String UPDATE_START_DATE_REMOVED = "Task start date has been removed." + NEWLINE;
	public static final String UPDATE_END_DATE_REMOVED = "Task end date has been removed." +NEWLINE;
	public static final Object UPDATE_TASK_DATE_INVALID = "Task Date is Invalid"+ NEWLINE;

	// DirectoryCommand messages
	public static final String DIRECTORY_CHANGED = "Directory changed to %s" + NEWLINE;
	public static final String DIRECTORY_NOT_CHANGED = "Directory has not been changed." + NEWLINE;
	public static final String DIRECTORY_INVALID = "The directory you selected is not valid." + NEWLINE;
	public static final String DIRECTORY_FILE_EXISTS = "The directory you selected contains an existing Taskie Database." + NEWLINE;
	public static final String DIRECTORY_CHANGE_FAILED = "Directory change failed." + NEWLINE;

	// help messages
	public static final String ADD_HELP_HEADER = "HELP: Add a New Task " + NEWLINE;
	public static final String ADD_HELP_BODY = "add <task title> " + "[from/on/between/by/in/at/on <start date/time>] " + "[to/till <end date/time>]" + NEWLINE + NEWLINE;

	public static final String VIEW_HELP_HEADER = "HELP: View and Search Existing Tasks" + NEWLINE;
	public static final String VIEW_HELP_BODY = "view [all/undone/done/due]" + NEWLINE + NEWLINE;

	public static final String UPDATE_HELP_HEADER = "HELP: Update an Existing Task" + NEWLINE;
	public static final String UPDATE_HELP_BODY = "update <task number> [<task title>] " + "[from <start date/time> to <end date/time> / by <end date/time>]" + NEWLINE + NEWLINE;

	public static final String DELETE_HELP_HEADER = "HELP: Delete an Existing Task" + NEWLINE;
	public static final String DELETE_HELP_BODY = "delete <task number>" + NEWLINE + NEWLINE;

	public static final String UNDO_HELP_HEADER = "HELP: Undo One or More Actions" + NEWLINE;
	public static final String UNDO_HELP_BODY = "undo [<number of steps>]" + NEWLINE + NEWLINE;

	public static final String REDO_HELP_HEADER = "HELP: Redo One or More Actions" + NEWLINE;
	public static final String REDO_HELP_BODY = "redo [<number of steps>]" + NEWLINE + NEWLINE;

	public static final String MARK_HELP_HEADER = "HELP: Mark a Task as Done" + NEWLINE;
	public static final String MARK_HELP_BODY = "mark <task number>" + NEWLINE + NEWLINE;

	public static final String UNMARK_HELP_HEADER = "HELP: Mark a Task as Undone" + NEWLINE;
	public static final String UNMARK_HELP_BODY = "unmark <task number>" + NEWLINE + NEWLINE;

	public static final String DIRECTORY_HELP_HEADER = "HELP: Change Storage Directory" + NEWLINE;
	public static final String DIRECTORY_HELP_BODY = "directory <new path>" + NEWLINE + NEWLINE;

	public static final String EXIT_HELP_HEADER = "HELP: Exit Taskie" + NEWLINE;
	public static final String EXIT_HELP_BODY = "exit" + NEWLINE + NEWLINE;

	// error messages
	public static final String INVALID_TASK_NUM = "Invalid task number. Please try again." + NEWLINE;
	public static final String INVALID_COMMAND = "Invalid Command. Please try again." + NEWLINE;

	// UndoCommand messages
	public static final String NOTHING_TO_UNDO = "Nothing to undo." + NEWLINE;
	public static final String UNDO_FAILED = "Undo failed: %s" + NEWLINE;

	// RedoCommand messages
	public static final String NOTHING_TO_REDO = "Nothing to redo." + NEWLINE;
	public static final String REDO_FAILED = "Redo failed: %s" + NEWLINE;

	// Exception messages
	public static final String CONFIGURATION_FAILED_EXCEPTION = "The configuration could not be settled." + NEWLINE;
	public static final String FILE_EXISTS_EXCEPTION = "A file already exists at this directory." + NEWLINE;
	public static final String INVALID_COMMAND_EXCEPTION = "The command could not be parsed." + NEWLINE;
	public static final String INVALID_TASK_EXCEPTION = "The task is not valid" + NEWLINE;
	public static final String NOTHING_TO_REDO_EXCEPTION = "There is nothing to redo." + NEWLINE;
	public static final String STORAGE_LOCATION_INVALID_EXCEPTION = "Storage Location is invalid" + NEWLINE;
	public static final String STORAGE_MIGRATION_FAILED_EXCEPTION = "Storage Location is invalid" + NEWLINE;
	public static final String TASK_DATE_INVALID_EXCEPTION = "Invalid date and time set in task" + NEWLINE;
	public static final String TASK_DATE_NOT_SET_EXCEPTION = "A date has not been set for the task." + NEWLINE;
	public static final String TASK_MODIFICATION_FAILED_EXCEPTION = "Task modification failed" + NEWLINE;
	public static final String TASK_RETRIEVAL_FAILED_EXCEPTION = "Failed to retrieve task(s)" + NEWLINE;
	public static final String TASK_TYPE_NOT_SUPPORTED_EXCEPTION = "This task type is not supported." + NEWLINE;
	public static final String UNDO_NOT_SUPPORTED_EXCEPTION = "Undo is not supported for this command" + NEWLINE;
	public static final String SECURITY_EXCEPTION = "SecurityException: Unable to setup logging." + NEWLINE;
	public static final String IO_EXCEPTION = "IOException: Unable to setup logging." + NEWLINE;
	public static final String UNKNOWN_EXCEPTION = "Unknown Error: ";
	public static final String STORAGE_INITIALISATION_ERROR = "Critital: Unable to initialize Storage System";
}
	// End of segment: src\taskie\models\Messages.java





	/**
	 * origin: src\taskie\models\Task.java
	 */

	public Task(Task task) {
		_title = task.getTitle();
		_startDate = task.getStartDate();
		_startTime = task.getStartTime();
		_endDate = task.getEndDate();
		_endTime = task.getEndTime();
		_isDone = task.isDone();
	}

	// End of segment: src\taskie\models\Task.java





	/**
	 * origin: src\taskie\models\Task.java
	 */

	// this constructor is used to duplicate a task.
	public int compareTo(Task other) {
		LocalDateTime thisTaskDateTime = LocalDateTime.of(this.getEndDate(), this.getEndTime());
		LocalDateTime otherTaskDateTime = LocalDateTime.of(other.getEndDate(), other.getEndTime());
		return thisTaskDateTime.compareTo(otherTaskDateTime);
	}

	public int compareTo(LocalDateTime now) {
		LocalDateTime thisTaskDateTime = LocalDateTime.of(this.getEndDate(), this.getEndTime());
		return thisTaskDateTime.compareTo(now);
	}

	// End of segment: src\taskie\models\Task.java





	/**
	 * origin: src\taskie\models\TaskEndDateComparator.java
	 */

import java.time.LocalDateTime;
import java.util.Comparator;

public class TaskEndDateComparator implements Comparator<Task> {

	public TaskEndDateComparator() {
		
	}

	@Override
	public int compare(Task o1, Task o2) {
		if(o1.getEndDate()==null){
			if(o2.getEndDate()==null){
				return 0;
			}
			else{
				return 1;
			}
		}else{
			if(o2.getEndDate()==null){
				return -1;
			}
		}
		LocalDateTime o1DateTime = o1.getEndDateTime();
		LocalDateTime o2DateTime = o2.getEndDateTime();
		return o1DateTime.compareTo(o2DateTime);
		
	}
	public int equals(Task o1, Task o2){
		if(o1.getEndDate()==o2.getEndDate()){
			return 1;
		}
		return 0;
	}

}

	// End of segment: src\taskie\models\TaskEndDateComparator.java





	/**
	 * origin: src\taskie\tests\CommandTest.java
	 */

package taskie.tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import taskie.Controller;
import taskie.commands.AddCommand;
import taskie.commands.DeleteCommand;
import taskie.commands.DirectoryCommand;
import taskie.commands.MarkCommand;
import taskie.commands.RedoCommand;
import taskie.commands.UndoCommand;
import taskie.commands.UnmarkCommand;
import taskie.commands.UpdateCommand;
import taskie.commands.ViewCommand;
import taskie.exceptions.InvalidCommandException;
import taskie.exceptions.InvalidTaskException;
import taskie.exceptions.TaskDateInvalidException;
import taskie.exceptions.TaskDateNotSetException;
import taskie.exceptions.TaskModificationFailedException;
import taskie.exceptions.TaskRetrievalFailedException;
import taskie.models.Task;
import taskie.models.ViewType;

public class CommandTest {
	private static Controller _controller;

	private static LocalDate _time1Date;
	private static LocalTime _time1Time;

	private static LocalDate _time2Date;
	private static LocalTime _time2Time;
	
	private static LocalDate _time3Date;
	private static LocalTime _time3Time;
	
	private static LocalDateTime _time1;
	private static LocalDateTime _time2;
	private static LocalDateTime _time3;

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		_controller = Controller.getInstance();
		_time1 = LocalDateTime.of(2100,1,2,13,0);
		_time2 = _time1.plusHours(2);
		_time3 = _time1.plusDays(1);
		
		_time1Date = _time1.toLocalDate();
		_time1Time = _time1.toLocalTime();
		
		_time2Date = _time2.toLocalDate();
		_time2Time = _time2.toLocalTime();
		
		_time3Date = _time3.toLocalDate();
		_time3Time = _time3.toLocalTime();
	}

	@AfterClass
	public static void cleanUp() throws IOException, TaskRetrievalFailedException, TaskModificationFailedException {
		_controller.getStorage().clearAllTasks();
	}

	@Before
	public void setUp() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException {
		_controller.getStorage().clearAllTasks();
	}

	@Test
	public void testAddCommandFloating() throws InvalidCommandException,
			InvalidTaskException, TaskRetrievalFailedException, IOException, TaskModificationFailedException {
		setUp();
		addTask("foo",null,null);
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		
		Task expectedTask = new Task("foo");
		assertEquals(expectedTask.toString(), list.get(0).toString());
	}

	@Test
	public void testAddCommandDeadline() throws TaskRetrievalFailedException,
			IOException, TaskModificationFailedException {
		setUp();
		addTask("bar",null,_time1);
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		
		Task expectedTask = new Task("bar", _time1Date, _time1Time);
		assertEquals(expectedTask.toString(), list.get(0).toString());
	}

	@Test
	public void testAddCommandTimed() throws TaskRetrievalFailedException,
			IOException, TaskModificationFailedException {
		setUp();
		AddCommand cmd = new AddCommand();
		addTask("foobar",_time1,_time2);
		_controller.executeCommand(cmd);
		ArrayList<Task> list = _controller.getStorage().getTaskList();
	
		Task expectedTask = new Task("foobar", _time1Date, _time1Time, _time2Date,
				_time2Time);
		assertEquals(expectedTask.toString(), list.get(0).toString());
	}

	@Test
	public void testViewCommandAll() throws TaskRetrievalFailedException,
			IOException, TaskModificationFailedException, InvalidTaskException {
		setUp();
		generateTasks();
		ViewCommand cmd = new ViewCommand(ViewType.ALL);
		cmd.execute();
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[10]));
		assertEquals(10, _controller.getUI().getCurrentTaskList().length);
	}
	
	@Test
	public void testViewCommandSearchTaskName() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException, InvalidTaskException{
		setUp();
		generateTasks();
		AddCommand cmd = new AddCommand();
		cmd.setTaskName("bar");
		cmd.execute();
		ViewCommand view = new ViewCommand(ViewType.SEARCH);
		view.setSearchKeywords("bar");
		view.execute();
		assertEquals(1,_controller.getUI().getCurrentTaskList().length);
	}
	
	
	@Test
	public void testViewCommandSearchfromStartDate() throws InvalidTaskException, TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		generateTasks();
		ViewCommand view = new ViewCommand(ViewType.SEARCH);
		view.setStartDate(_time3Date);
		view.execute();
		assertEquals(8,_controller.getUI().getCurrentTaskList().length);
	}
	
	@Test
	public void testViewCommandSearchByEndDate() throws InvalidTaskException, TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		generateTasks();
		ViewCommand view = new ViewCommand(ViewType.SEARCH);
		view.setEndDate(_time2Date);
		view.execute();
		assertEquals(7,_controller.getUI().getCurrentTaskList().length);
	}
	
	@Test
	public void testViewCommandSearchBetweenDates() throws InvalidTaskException, TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		generateTasks();
		ViewCommand view = new ViewCommand(ViewType.SEARCH);
		view.setStartDate(_time1Date);
		view.setEndDate(_time3Date);
		view.execute();
		assertEquals(10,_controller.getUI().getCurrentTaskList().length);
	}
	
	
	@Test
	public void testViewUpcoming() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException, InvalidTaskException{
		setUp();
		generateTasks();
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[10]));
		int[] intArr= {1,3,5};
		MarkCommand mark = new MarkCommand(intArr);
		mark.execute();
		ViewCommand view = new ViewCommand(ViewType.UPCOMING);
		view.execute();
		assertEquals(7,_controller.getUI().getCurrentTaskList().length);
	}
	
	
	@Test
	public void testUpdateCommandTaskName()
			throws TaskRetrievalFailedException, IOException,
			InvalidTaskException, TaskDateNotSetException, TaskDateInvalidException, TaskModificationFailedException {
		setUp();
		addTask("foo",_time1,_time2);
		ArrayList<Task> tasks = _controller.getStorage().getTaskList();
		_controller.getUI()
				.display(tasks.toArray(new Task[tasks.size()]));
		UpdateCommand update = new UpdateCommand(1);
		update.setTaskTitleToUpdate("bar");
		update.execute();
		
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		Task expectedTask = new Task("bar",_time1,_time2);
		assertEquals(expectedTask.toString(), list.get(0).toString());

	}

	@Test
	public void testUpdateCommandEndTime() throws TaskRetrievalFailedException,
			IOException, InvalidTaskException, TaskDateNotSetException, TaskDateInvalidException, TaskModificationFailedException {
		setUp();
		addTask("foo",null,_time1);
		ArrayList<Task> tasks = _controller.getStorage().getTaskList();
		_controller.getUI()
				.display(tasks.toArray(new Task[tasks.size()]));
		UpdateCommand update = new UpdateCommand(1);
		update.setEndDateToUpdate(_time2Date);
		update.setEndTimeToUpdate(_time2Time);
		update.execute();
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		Task expectedTask = new Task("foo",_time2);
		assertEquals(expectedTask.toString(), list.get(0).toString());
	}

	@Test
	public void testUpdateCommandStartEndDateTime()
			throws TaskRetrievalFailedException, IOException,
			InvalidTaskException, TaskDateNotSetException, TaskDateInvalidException, TaskModificationFailedException {
		setUp();
		addTask("foo",_time1,_time2);
		ArrayList<Task> tasks = _controller.getStorage().getTaskList();
		_controller.getUI()
				.display(tasks.toArray(new Task[tasks.size()]));
		UpdateCommand update = new UpdateCommand(1);
		update.setEndDateToUpdate(_time3Date);
		update.setEndTimeToUpdate(_time3Time);
		update.setStartDateToUpdate(_time2Date);
		update.setStartTimeToUpdate(_time2Time);
		update.execute();
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		Task expectedTask = new Task("foo",_time2,_time3);

		assertEquals(expectedTask.toString(), list.get(0).toString());
	}


	
	//startdate and enddate of task is 2 hours apart, updatecommand updates startdate to the nextday
	@Test
	public void testUpdateCommandUpdateToStartTimeAfterEndTime()
			throws TaskRetrievalFailedException, IOException,
			InvalidTaskException, TaskDateNotSetException, TaskDateInvalidException, TaskModificationFailedException {
		setUp();
		addTask("foo",_time1,_time3);
		
		ArrayList<Task> tasks = _controller.getStorage().getTaskList();
		_controller.getUI().display(tasks.toArray(new Task[tasks.size()]));
		UpdateCommand update = new UpdateCommand(1);
		update.setStartDateToUpdate(_time2Date);
		update.setStartTimeToUpdate(_time2Time);
		update.execute();
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		
		long difference = ChronoUnit.NANOS.between(_time1, _time2);
		
		Task expectedTask = new Task("foo",_time2,_time3.plusNanos(difference));
		assertEquals(expectedTask.toString(), list.get(0).toString());	
	}
	
	
	@Test
	public void testUpdateCommandNoIndexReference()
			throws TaskRetrievalFailedException, IOException,
			InvalidTaskException, TaskDateNotSetException, TaskDateInvalidException, TaskModificationFailedException {
		setUp();
		addTask("foo",_time1,_time2);
		
		UpdateCommand update = new UpdateCommand(0);
		update.setTaskTitleToUpdate("bar");
		update.execute();
		
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		Task expectedTask = new Task("bar",_time1,_time2);
		assertEquals(expectedTask.toString(), list.get(0).toString());
	}
	
	@Test
	public void testDeleteCommandTaskName() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		addTask("foo",null,null);
		addTask("bar",null,null);
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[2]));
		DeleteCommand delete = new DeleteCommand(1);
		delete.execute();
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		assertEquals(1,list.size());
	}
	
	@Test
	public void testDeleteCommandStartDateTime() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		addTask("foo",_time1,_time2);
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[1]));
		DeleteCommand delete = new DeleteCommand(1);
		delete.setToDeleteStartDate();
		delete.execute();
		Task expectedTask = new Task("foo",_time2);
		assertEquals(expectedTask.toString(),_controller.getStorage().getTaskList().get(0).toString());
	}
	
	@Test
	public void testDeleteCommandStartEndDateTime() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		addTask("foo",_time1,_time2);
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[1]));
		DeleteCommand delete = new DeleteCommand(1);
		delete.setToDeleteStartDate();
		delete.setToDeleteEndDate();
		delete.execute();
		Task expectedTask = new Task("foo");
		assertEquals(expectedTask.toString(),_controller.getStorage().getTaskList().get(0).toString());
		
	}
	
	
	@Test
	public void testDeleteCommandEndDateTime() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		addTask("foo",_time1,_time2);
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[1]));
		DeleteCommand delete = new DeleteCommand(1);
		delete.setToDeleteEndDate();
		delete.execute();
		Task expectedTask = new Task("foo",_time1);
		assertEquals(expectedTask.toString(),_controller.getStorage().getTaskList().get(0).toString());
	}
	
	@Test
	public void testDeleteCommandStartEndTime() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		addTask("foo",_time1,_time2);
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[1]));
		DeleteCommand delete = new DeleteCommand(1);
		delete.setToDeleteStartTime();
		delete.setToDeleteEndTime();
		delete.execute();
		LocalDate startDate= _time1.toLocalDate();
		LocalDate endDate = _time2.toLocalDate();
		Task expectedTask = new Task("foo",startDate,endDate);
		assertEquals(expectedTask.toString(),_controller.getStorage().getTaskList().get(0).toString());
	}
	
	
	@Test 
	public void testMarkAndUnmarkCommand() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		addTask("foo",null,null);
		
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[1]));
		MarkCommand mark = new MarkCommand(1);
		mark.execute();
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		assertEquals(true,list.get(0).isDone());
		
		_controller.getUI().display(_controller.getStorage().getTaskList().toArray(new Task[1]));
		UnmarkCommand unmark = new UnmarkCommand(1);
		unmark.execute();
		list = _controller.getStorage().getTaskList();
		assertEquals(false,list.get(0).isDone());	
	}

	@Test
	public void testUndoAndRedoCommandSingleStep() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		AddCommand cmd = new AddCommand("foo",null,null);
		_controller.executeCommand(cmd);
		UndoCommand undo = new UndoCommand();
		undo.execute();
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		assertEquals(0,list.size());
		RedoCommand redo = new RedoCommand();
		redo.execute();
		list = _controller.getStorage().getTaskList();
		assertEquals(1,list.size());
	}
	@Test
	public void testUndoAndRedoCommandMultipleSteps() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		setUp();
		AddCommand cmd = new AddCommand("foo",null,null);
		_controller.executeCommand(cmd);
		cmd =  new AddCommand("bar",null,null);
		_controller.executeCommand(cmd);
		UndoCommand undo = new UndoCommand(2);
		undo.execute();
		ArrayList<Task> list = _controller.getStorage().getTaskList();
		assertEquals(0,list.size());
		RedoCommand redo = new RedoCommand(2);
		redo.execute();
		list = _controller.getStorage().getTaskList();
		assertEquals(2,list.size());
	}

	
	// End of segment: src\taskie\tests\CommandTest.java





	/**
	 * origin: src\taskie\tests\CommandTest.java
	 */

	private void addTask(String taskName,LocalDateTime startDateTime, LocalDateTime endDateTime) {
		AddCommand cmd = new AddCommand();
		cmd.setTaskName(taskName);
		if(startDateTime!=null){
			cmd.setStartDateTime(startDateTime);
		}
		if(endDateTime!=null){
			cmd.setEndDateTime(endDateTime);
		}
		cmd.execute();
	}
	

	
	

	private void generateTasks() {
		for (int i = 0; i < 10; i++) {
			AddCommand cmd = new AddCommand();
			cmd.setTaskName("foo " + i);
			if (i % 2 == 0) {
				cmd.setEndDateTime(_time2.plusHours(i*3));
				if (i % 3 == 0) {
					cmd.setStartDateTime(_time1.plusHours(i*3));
				}
			}
			cmd.execute();
		}
		
	}

}

	// End of segment: src\taskie\tests\CommandTest.java





	/**
	 * origin: src\taskie\tests\FunctionalTest.java
	 */

package taskie.tests;

import static org.junit.Assert.assertEquals;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import taskie.Controller;
import taskie.commands.Command;
import taskie.exceptions.InvalidCommandException;
import taskie.exceptions.TaskModificationFailedException;
import taskie.exceptions.TaskRetrievalFailedException;
import taskie.models.DateTimeSource;
import taskie.models.Task;

public class FunctionalTest {
	private static Controller _controller;
	
	LocalDateTime _now = LocalDateTime.now();
	LocalDateTime _today10pm = LocalDateTime.of(_now.toLocalDate(), LocalTime.of(22, 0, 0, 0));
	LocalDateTime _today2pm = LocalDateTime.of(_now.toLocalDate(), LocalTime.of(14,0,0,0));
	
	@After
	public void tearDownAfterClass() throws Exception {
		_controller.getStorage().clearAllTasks();
		_controller.resetUndoAndRedoStacks();
	}
	
	@Before
	public void setUp() throws TaskRetrievalFailedException, IOException, TaskModificationFailedException {
		DateTimeSource.setCurrentDateTime(_now);
		_controller = Controller.getInstance();
		_controller.getStorage().clearAllTasks();
	}

	@Test
	public void testAddFloating() throws InvalidCommandException, TaskRetrievalFailedException, IOException, TaskModificationFailedException {
		Command cmd = _controller.getParser().parse("add taskname");
		_controller.executeCommand(cmd);
		Task expectedTask = new Task("taskname");
		assertEquals(expectedTask.toString(),_controller.getStorage().getTaskList().get(0).toString());
	}
	@Test
	public void testAddDeadline() throws InvalidCommandException, TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		Command cmd=null;
		
		try {
			cmd = _controller.getParser().parse("add taskname by 10pm");
		} catch (Exception e) {
			e.printStackTrace();
		}
		_controller.executeCommand(cmd);
		Task expectedTask = null;
		if(LocalTime.now().isAfter(_today10pm.toLocalTime())){
			expectedTask = new Task("taskname", _today10pm.plusDays(1));
		}else{
			expectedTask = new Task("taskname",_today10pm);
		}
		assertEquals(expectedTask.toString(),_controller.getStorage().getTaskList().get(0).toString());
	}
	
	@Test
	public void testAddTimed() throws InvalidCommandException, TaskRetrievalFailedException, IOException, TaskModificationFailedException{
		Command cmd=null;
		
		try {
			cmd = _controller.getParser().parse("add taskname from 2pm to 10pm");
		} catch (Exception e) {
			e.printStackTrace();
		}
		_controller.executeCommand(cmd);
		Task expectedTask = null;
		if(LocalTime.now().isAfter(_today2pm.toLocalTime())){
			expectedTask = new Task("taskname",_today2pm.plusDays(1),_today10pm.plusDays(1));
		}else{
			expectedTask = new Task("taskname",_today2pm,_today10pm);
		}
		
		assertEquals(expectedTask.toString(),_controller.getStorage().getTaskList().get(0).toString());
	}
	
	// End of segment: src\taskie\tests\FunctionalTest.java





